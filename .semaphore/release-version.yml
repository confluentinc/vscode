version: v1.0
name: release-version
agent:
  machine:
    type: s1-prod-ubuntu24-04-amd64-1

auto_cancel:
  running:
    when: "branch != 'main'"

execution_time_limit:
  hours: 1

queue:
  - when: "branch != 'main'"
    processing: parallel

global_job_config:
  prologue:
    commands:
      - checkout
      - |
          if [ -n "$TARGET_BRANCH" ]; then
            git fetch origin "$TARGET_BRANCH:$TARGET_BRANCH"
          else
            git fetch --all
          fi
          if [ -z "$COMMIT_SHA" ]; then
            COMMIT_SHA=$(git rev-parse HEAD)
          fi
          git checkout "$COMMIT_SHA"
      - . vault-setup
  env_vars:
    - name: NODE_ENV
      value: "production"

blocks:
  - name: "Delete GitHub Release and Tag"
    dependencies: []
    task:
      jobs:
        - name: "Delete GitHub Release and Tag"
          commands:
            # Adjust RELEASE_NAME for prereleases, if necessary
            - |
              if [ "$IS_PRERELEASE" = "true" ]; then
                if [[ "$RELEASE_NAME" != *"-pre"* ]]; then
                  RELEASE_NAME="${RELEASE_NAME}-pre"
                fi
              fi
            # Delete the existing GitHub Release and tag if they exist
            - gh release delete "$RELEASE_NAME" --yes || true
            - git tag -d "$RELEASE_NAME" || true
            - git push origin --delete "$RELEASE_NAME" || true
  - name: "Create GitHub Release and Tag"
    dependencies: ["Delete GitHub Release and Tag"]
    task:
      jobs:
        - name: "Create GitHub Release and Tag"
          commands:
            # Adjust RELEASE_NAME for prereleases, if necessary
            - |
              if [ "$IS_PRERELEASE" = "true" ]; then
                PRE_RELEASE_FLAG="--prerelease"
                if [[ "$RELEASE_NAME" != *"-pre"* ]]; then
                  RELEASE_NAME="${RELEASE_NAME}-pre"
                fi
              else
                PRE_RELEASE_FLAG=""
              fi
            # Try to determine previous release tag for generating release notes
            - |
              if [ -n "$PREVIOUS_RELEASE_TAG" ] && [ "$PREVIOUS_RELEASE_TAG" != "PREVIOUS_RELEASE_TAG" ]; then
                PREV_TAG="$PREVIOUS_RELEASE_TAG"
                echo "Using provided PREVIOUS_RELEASE_TAG: $PREV_TAG"
                NOTES_FLAGS="--generate-notes --notes-start-tag $PREV_TAG"
              else
                echo "Looking up the latest non-prerelease GitHub release tag..."
                PREV_TAG=$(gh release list --limit 10 --json tagName,isPrerelease --jq '.[] | select(.isPrerelease == false) | .tagName' | head -n 1)
                if [ -z "$PREV_TAG" ]; then
                  echo "No previous non-prerelease tag found. Skipping automatic release notes generation."
                  NOTES_FLAGS=""
                else
                  echo "Found previous release tag: $PREV_TAG"
                  NOTES_FLAGS="--generate-notes --notes-start-tag $PREV_TAG"
                fi
              fi
            # Create the GitHub release, possibly with automatically-generated notes
            - |
              gh release create "$RELEASE_NAME" \
                $PRE_RELEASE_FLAG \
                --target "$COMMIT_SHA" \
                --title "$RELEASE_NAME" \
                $NOTES_FLAGS
  - name: "Package VSIX Files"
    dependencies: ["Create GitHub Release and Tag"]
    task:
      prologue:
        commands:
          - make install-dependencies
      jobs:
        - name: "Package VSIX Files"
          matrix:
            - env_var: TARGET
              values:
                - darwin-x64
                - darwin-arm64
                - linux-x64
                - linux-arm64
                - win32-x64
          commands:
            # Adjust RELEASE_NAME for prereleases, if necessary
            - |
              if [ "$IS_PRERELEASE" = "true" ]; then
                PRE_RELEASE_FLAG="--prerelease"
                if [[ "$RELEASE_NAME" != *"-pre"* ]]; then
                  RELEASE_NAME="${RELEASE_NAME}-pre"
                fi
              else
                PRE_RELEASE_FLAG=""
              fi
            - |
              case "$TARGET" in
                darwin-x64)  export SIDECAR_OS_ARCH=macos-amd64 ;;
                darwin-arm64) export SIDECAR_OS_ARCH=macos-arm64 ;;
                linux-x64)   export SIDECAR_OS_ARCH=linux-amd64 ;;
                linux-arm64) export SIDECAR_OS_ARCH=linux-arm64 ;;
                win32-x64)   export SIDECAR_OS_ARCH=windows-x64 ;;
                *) echo "Unknown TARGET: $TARGET" && exit 1 ;;
              esac
            - make download-sidecar-executable
            - make download-third-party-notices-sidecar || true
            - npx gulp bundle
            - VSIX_FILE=$(find out/ -name "*.vsix")
            # Remove the existing (micro-versioned) version and replace with RELEASE_NAME
            - |
              ARTIFACT_FILENAME=$(basename "${VSIX_FILE}")
              prefix="${ARTIFACT_FILENAME%%${TARGET}*}${TARGET}"
              ARTIFACT_FILENAME="${prefix}-${RELEASE_NAME}.vsix"
            - artifact push workflow ${VSIX_FILE} --destination packaged-vsix-files/${ARTIFACT_FILENAME} --force
  - name: "Multi-arch Packaging and Upload"
    dependencies: ["Package VSIX Files"]
    task:
      jobs:
        - name: "Multi-arch Packaging and Upload"
          commands:
            # Adjust RELEASE_NAME for prereleases, if necessary
            - |
              if [ "$IS_PRERELEASE" = "true" ]; then
                PRE_RELEASE_FLAG="--prerelease"
                if [[ "$RELEASE_NAME" != *"-pre"* ]]; then
                  RELEASE_NAME="${RELEASE_NAME}-pre"
                fi
              else
                PRE_RELEASE_FLAG=""
              fi
            - artifact pull workflow packaged-vsix-files/
            - |
              for vsix in packaged-vsix-files/*.vsix; do
                gh release upload "$RELEASE_NAME" "$vsix" --clobber
              done
