/* tslint:disable */
/* eslint-disable */
/**
 * Confluent Schema Registry APIs
 * REST API for the Schema Registry
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: data-governance@confluent.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
  ErrorMessage,
  RegisterSchemaRequest,
  RegisterSchemaResponse,
  Schema,
} from "../models/index";
import {
  ErrorMessageFromJSON,
  ErrorMessageToJSON,
  RegisterSchemaRequestFromJSON,
  RegisterSchemaRequestToJSON,
  RegisterSchemaResponseFromJSON,
  RegisterSchemaResponseToJSON,
  SchemaFromJSON,
  SchemaToJSON,
} from "../models/index";

export interface DeleteSchemaVersionRequest {
  subject: string;
  version: string;
  permanent?: boolean;
}

export interface DeleteSubjectRequest {
  subject: string;
  permanent?: boolean;
}

export interface GetReferencedByRequest {
  subject: string;
  version: string;
}

export interface GetSchemaByVersionRequest {
  subject: string;
  version: string;
  deleted?: boolean;
}

export interface GetSchemaOnly1Request {
  subject: string;
  version: string;
  deleted?: boolean;
}

export interface ListRequest {
  subjectPrefix?: string;
  deleted?: boolean;
}

export interface ListVersionsRequest {
  subject: string;
  deleted?: boolean;
}

export interface LookUpSchemaUnderSubjectRequest {
  subject: string;
  RegisterSchemaRequest: RegisterSchemaRequest;
  normalize?: boolean;
  deleted?: boolean;
}

export interface RegisterRequest {
  subject: string;
  RegisterSchemaRequest: RegisterSchemaRequest;
  normalize?: boolean;
}

/**
 *
 */
export class SubjectsV1Api extends runtime.BaseAPI {
  /**
   * Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema.
   * Delete schema version
   */
  async deleteSchemaVersionRaw(
    requestParameters: DeleteSchemaVersionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<number>> {
    if (requestParameters["subject"] == null) {
      throw new runtime.RequiredError(
        "subject",
        'Required parameter "subject" was null or undefined when calling deleteSchemaVersion().',
      );
    }

    if (requestParameters["version"] == null) {
      throw new runtime.RequiredError(
        "version",
        'Required parameter "version" was null or undefined when calling deleteSchemaVersion().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["permanent"] != null) {
      queryParameters["permanent"] = requestParameters["permanent"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/subjects/{subject}/versions/{version}`
          .replace(`{${"subject"}}`, encodeURIComponent(String(requestParameters["subject"])))
          .replace(`{${"version"}}`, encodeURIComponent(String(requestParameters["version"]))),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<number>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema.
   * Delete schema version
   */
  async deleteSchemaVersion(
    requestParameters: DeleteSchemaVersionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<number> {
    const response = await this.deleteSchemaVersionRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Deletes the specified subject and its associated compatibility level if registered. It is recommended to use this API only when a topic needs to be recycled or in development environment.
   * Delete subject
   */
  async deleteSubjectRaw(
    requestParameters: DeleteSubjectRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<number>>> {
    if (requestParameters["subject"] == null) {
      throw new runtime.RequiredError(
        "subject",
        'Required parameter "subject" was null or undefined when calling deleteSubject().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["permanent"] != null) {
      queryParameters["permanent"] = requestParameters["permanent"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/subjects/{subject}`.replace(
          `{${"subject"}}`,
          encodeURIComponent(String(requestParameters["subject"])),
        ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Deletes the specified subject and its associated compatibility level if registered. It is recommended to use this API only when a topic needs to be recycled or in development environment.
   * Delete subject
   */
  async deleteSubject(
    requestParameters: DeleteSubjectRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<number>> {
    const response = await this.deleteSubjectRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Retrieves the IDs of schemas that reference the specified schema.
   * List schemas referencing a schema
   */
  async getReferencedByRaw(
    requestParameters: GetReferencedByRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<number>>> {
    if (requestParameters["subject"] == null) {
      throw new runtime.RequiredError(
        "subject",
        'Required parameter "subject" was null or undefined when calling getReferencedBy().',
      );
    }

    if (requestParameters["version"] == null) {
      throw new runtime.RequiredError(
        "version",
        'Required parameter "version" was null or undefined when calling getReferencedBy().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/subjects/{subject}/versions/{version}/referencedby`
          .replace(`{${"subject"}}`, encodeURIComponent(String(requestParameters["subject"])))
          .replace(`{${"version"}}`, encodeURIComponent(String(requestParameters["version"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Retrieves the IDs of schemas that reference the specified schema.
   * List schemas referencing a schema
   */
  async getReferencedBy(
    requestParameters: GetReferencedByRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<number>> {
    const response = await this.getReferencedByRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Retrieves a specific version of the schema registered under this subject.
   * Get schema by version
   */
  async getSchemaByVersionRaw(
    requestParameters: GetSchemaByVersionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Schema>> {
    if (requestParameters["subject"] == null) {
      throw new runtime.RequiredError(
        "subject",
        'Required parameter "subject" was null or undefined when calling getSchemaByVersion().',
      );
    }

    if (requestParameters["version"] == null) {
      throw new runtime.RequiredError(
        "version",
        'Required parameter "version" was null or undefined when calling getSchemaByVersion().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["deleted"] != null) {
      queryParameters["deleted"] = requestParameters["deleted"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/subjects/{subject}/versions/{version}`
          .replace(`{${"subject"}}`, encodeURIComponent(String(requestParameters["subject"])))
          .replace(`{${"version"}}`, encodeURIComponent(String(requestParameters["version"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => SchemaFromJSON(jsonValue));
  }

  /**
   * Retrieves a specific version of the schema registered under this subject.
   * Get schema by version
   */
  async getSchemaByVersion(
    requestParameters: GetSchemaByVersionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Schema> {
    const response = await this.getSchemaByVersionRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Retrieves the schema for the specified version of this subject. Only the unescaped schema string is returned.
   * Get schema string by version
   */
  async getSchemaOnly1Raw(
    requestParameters: GetSchemaOnly1Request,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters["subject"] == null) {
      throw new runtime.RequiredError(
        "subject",
        'Required parameter "subject" was null or undefined when calling getSchemaOnly1().',
      );
    }

    if (requestParameters["version"] == null) {
      throw new runtime.RequiredError(
        "version",
        'Required parameter "version" was null or undefined when calling getSchemaOnly1().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["deleted"] != null) {
      queryParameters["deleted"] = requestParameters["deleted"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/subjects/{subject}/versions/{version}/schema`
          .replace(`{${"subject"}}`, encodeURIComponent(String(requestParameters["subject"])))
          .replace(`{${"version"}}`, encodeURIComponent(String(requestParameters["version"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Retrieves the schema for the specified version of this subject. Only the unescaped schema string is returned.
   * Get schema string by version
   */
  async getSchemaOnly1(
    requestParameters: GetSchemaOnly1Request,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<string> {
    const response = await this.getSchemaOnly1Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Retrieves a list of registered subjects matching specified parameters.
   * List subjects
   */
  async listRaw(
    requestParameters: ListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<string>>> {
    const queryParameters: any = {};

    if (requestParameters["subjectPrefix"] != null) {
      queryParameters["subjectPrefix"] = requestParameters["subjectPrefix"];
    }

    if (requestParameters["deleted"] != null) {
      queryParameters["deleted"] = requestParameters["deleted"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/subjects`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Retrieves a list of registered subjects matching specified parameters.
   * List subjects
   */
  async list(
    requestParameters: ListRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<string>> {
    const response = await this.listRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Retrieves a list of versions registered under the specified subject.
   * List versions under subject
   */
  async listVersionsRaw(
    requestParameters: ListVersionsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<number>>> {
    if (requestParameters["subject"] == null) {
      throw new runtime.RequiredError(
        "subject",
        'Required parameter "subject" was null or undefined when calling listVersions().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["deleted"] != null) {
      queryParameters["deleted"] = requestParameters["deleted"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/subjects/{subject}/versions`.replace(
          `{${"subject"}}`,
          encodeURIComponent(String(requestParameters["subject"])),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Retrieves a list of versions registered under the specified subject.
   * List versions under subject
   */
  async listVersions(
    requestParameters: ListVersionsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<number>> {
    const response = await this.listVersionsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Check if a schema has already been registered under the specified subject. If so, this returns the schema string along with its globally unique identifier, its version under this subject and the subject name.
   * Lookup schema under subject
   */
  async lookUpSchemaUnderSubjectRaw(
    requestParameters: LookUpSchemaUnderSubjectRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Schema>> {
    if (requestParameters["subject"] == null) {
      throw new runtime.RequiredError(
        "subject",
        'Required parameter "subject" was null or undefined when calling lookUpSchemaUnderSubject().',
      );
    }

    if (requestParameters["RegisterSchemaRequest"] == null) {
      throw new runtime.RequiredError(
        "RegisterSchemaRequest",
        'Required parameter "RegisterSchemaRequest" was null or undefined when calling lookUpSchemaUnderSubject().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["normalize"] != null) {
      queryParameters["normalize"] = requestParameters["normalize"];
    }

    if (requestParameters["deleted"] != null) {
      queryParameters["deleted"] = requestParameters["deleted"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/vnd.schemaregistry.v1+json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/subjects/{subject}`.replace(
          `{${"subject"}}`,
          encodeURIComponent(String(requestParameters["subject"])),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: RegisterSchemaRequestToJSON(requestParameters["RegisterSchemaRequest"]),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => SchemaFromJSON(jsonValue));
  }

  /**
   * Check if a schema has already been registered under the specified subject. If so, this returns the schema string along with its globally unique identifier, its version under this subject and the subject name.
   * Lookup schema under subject
   */
  async lookUpSchemaUnderSubject(
    requestParameters: LookUpSchemaUnderSubjectRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Schema> {
    const response = await this.lookUpSchemaUnderSubjectRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Register a new schema under the specified subject. If successfully registered, this returns the unique identifier of this schema in the registry. The returned identifier should be used to retrieve this schema from the schemas resource and is different from the schema\'s version which is associated with the subject. If the same schema is registered under a different subject, the same identifier will be returned. However, the version of the schema may be different under different subjects. A schema should be compatible with the previously registered schema or schemas (if there are any) as per the configured compatibility level. The configured compatibility level can be obtained by issuing a GET http:get:: /config/(string: subject). If that returns null, then GET http:get:: /config When there are multiple instances of Schema Registry running in the same cluster, the schema registration request will be forwarded to one of the instances designated as the primary. If the primary is not available, the client will get an error code indicating that the forwarding has failed.
   * Register schema under a subject
   */
  async registerRaw(
    requestParameters: RegisterRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<RegisterSchemaResponse>> {
    if (requestParameters["subject"] == null) {
      throw new runtime.RequiredError(
        "subject",
        'Required parameter "subject" was null or undefined when calling register().',
      );
    }

    if (requestParameters["RegisterSchemaRequest"] == null) {
      throw new runtime.RequiredError(
        "RegisterSchemaRequest",
        'Required parameter "RegisterSchemaRequest" was null or undefined when calling register().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["normalize"] != null) {
      queryParameters["normalize"] = requestParameters["normalize"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/vnd.schemaregistry.v1+json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/subjects/{subject}/versions`.replace(
          `{${"subject"}}`,
          encodeURIComponent(String(requestParameters["subject"])),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: RegisterSchemaRequestToJSON(requestParameters["RegisterSchemaRequest"]),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      RegisterSchemaResponseFromJSON(jsonValue),
    );
  }

  /**
   * Register a new schema under the specified subject. If successfully registered, this returns the unique identifier of this schema in the registry. The returned identifier should be used to retrieve this schema from the schemas resource and is different from the schema\'s version which is associated with the subject. If the same schema is registered under a different subject, the same identifier will be returned. However, the version of the schema may be different under different subjects. A schema should be compatible with the previously registered schema or schemas (if there are any) as per the configured compatibility level. The configured compatibility level can be obtained by issuing a GET http:get:: /config/(string: subject). If that returns null, then GET http:get:: /config When there are multiple instances of Schema Registry running in the same cluster, the schema registration request will be forwarded to one of the instances designated as the primary. If the primary is not available, the client will get an error code indicating that the forwarding has failed.
   * Register schema under a subject
   */
  async register(
    requestParameters: RegisterRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<RegisterSchemaResponse> {
    const response = await this.registerRaw(requestParameters, initOverrides);
    return await response.value();
  }
}
