/* tslint:disable */
/* eslint-disable */
/**
 * Confluent Schema Registry APIs
 * REST API for the Schema Registry
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
  CompatibilityCheckResponse,
  ErrorMessage,
  RegisterSchemaRequest,
} from "../models/index";
import {
  CompatibilityCheckResponseFromJSON,
  CompatibilityCheckResponseToJSON,
  ErrorMessageFromJSON,
  ErrorMessageToJSON,
  RegisterSchemaRequestFromJSON,
  RegisterSchemaRequestToJSON,
} from "../models/index";

export interface TestCompatibilityBySubjectNameRequest {
  subject: string;
  version: string;
  RegisterSchemaRequest: RegisterSchemaRequest;
  verbose?: boolean;
}

export interface TestCompatibilityForSubjectRequest {
  subject: string;
  RegisterSchemaRequest: RegisterSchemaRequest;
  verbose?: boolean;
}

/**
 *
 */
export class CompatibilityV1Api extends runtime.BaseAPI {
  /**
   * Test input schema against a particular version of a subject\'s schema for compatibility. The compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject\'s compatibility level was never changed, then the global compatibility level applies (http:get:: /config).
   * Test schema compatibility against a particular schema subject-version
   */
  async testCompatibilityBySubjectNameRaw(
    requestParameters: TestCompatibilityBySubjectNameRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<CompatibilityCheckResponse>> {
    if (requestParameters["subject"] == null) {
      throw new runtime.RequiredError(
        "subject",
        'Required parameter "subject" was null or undefined when calling testCompatibilityBySubjectName().',
      );
    }

    if (requestParameters["version"] == null) {
      throw new runtime.RequiredError(
        "version",
        'Required parameter "version" was null or undefined when calling testCompatibilityBySubjectName().',
      );
    }

    if (requestParameters["RegisterSchemaRequest"] == null) {
      throw new runtime.RequiredError(
        "RegisterSchemaRequest",
        'Required parameter "RegisterSchemaRequest" was null or undefined when calling testCompatibilityBySubjectName().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["verbose"] != null) {
      queryParameters["verbose"] = requestParameters["verbose"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/vnd.schemaregistry.v1+json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/compatibility/subjects/{subject}/versions/{version}`
          .replace(`{${"subject"}}`, encodeURIComponent(String(requestParameters["subject"])))
          .replace(`{${"version"}}`, encodeURIComponent(String(requestParameters["version"]))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: RegisterSchemaRequestToJSON(requestParameters["RegisterSchemaRequest"]),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      CompatibilityCheckResponseFromJSON(jsonValue),
    );
  }

  /**
   * Test input schema against a particular version of a subject\'s schema for compatibility. The compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject\'s compatibility level was never changed, then the global compatibility level applies (http:get:: /config).
   * Test schema compatibility against a particular schema subject-version
   */
  async testCompatibilityBySubjectName(
    requestParameters: TestCompatibilityBySubjectNameRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<CompatibilityCheckResponse> {
    const response = await this.testCompatibilityBySubjectNameRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Test input schema against a subject\'s schemas for compatibility, based on the configured compatibility level of the subject. In other words, it will perform the same compatibility check as register for that subject. The compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject\'s compatibility level was never changed, then the global compatibility level applies (http:get:: /config).
   * Test schema compatibility against all schemas under a subject
   */
  async testCompatibilityForSubjectRaw(
    requestParameters: TestCompatibilityForSubjectRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<CompatibilityCheckResponse>> {
    if (requestParameters["subject"] == null) {
      throw new runtime.RequiredError(
        "subject",
        'Required parameter "subject" was null or undefined when calling testCompatibilityForSubject().',
      );
    }

    if (requestParameters["RegisterSchemaRequest"] == null) {
      throw new runtime.RequiredError(
        "RegisterSchemaRequest",
        'Required parameter "RegisterSchemaRequest" was null or undefined when calling testCompatibilityForSubject().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["verbose"] != null) {
      queryParameters["verbose"] = requestParameters["verbose"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/vnd.schemaregistry.v1+json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/compatibility/subjects/{subject}/versions`.replace(
          `{${"subject"}}`,
          encodeURIComponent(String(requestParameters["subject"])),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: RegisterSchemaRequestToJSON(requestParameters["RegisterSchemaRequest"]),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      CompatibilityCheckResponseFromJSON(jsonValue),
    );
  }

  /**
   * Test input schema against a subject\'s schemas for compatibility, based on the configured compatibility level of the subject. In other words, it will perform the same compatibility check as register for that subject. The compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject\'s compatibility level was never changed, then the global compatibility level applies (http:get:: /config).
   * Test schema compatibility against all schemas under a subject
   */
  async testCompatibilityForSubject(
    requestParameters: TestCompatibilityForSubjectRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<CompatibilityCheckResponse> {
    const response = await this.testCompatibilityForSubjectRaw(requestParameters, initOverrides);
    return await response.value();
  }
}
