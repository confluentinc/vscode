/* tslint:disable */
/* eslint-disable */
/**
 * REST Admin API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
  AlterConfigBatchRequestData,
  AlterMirrorStatusResponseDataList,
  AlterMirrorsRequestData,
  CreateLinkRequestData,
  CreateMirrorTopicRequestData,
  ListLinkConfigsResponseData,
  ListLinkConfigsResponseDataList,
  ListLinksResponseData,
  ListLinksResponseDataList,
  ListMirrorTopicsResponseData,
  ListMirrorTopicsResponseDataList,
  MirrorTopicStatus,
  UpdateLinkConfigRequestData,
} from "../models/index";
import {
  AlterConfigBatchRequestDataFromJSON,
  AlterConfigBatchRequestDataToJSON,
  AlterMirrorStatusResponseDataListFromJSON,
  AlterMirrorStatusResponseDataListToJSON,
  AlterMirrorsRequestDataFromJSON,
  AlterMirrorsRequestDataToJSON,
  CreateLinkRequestDataFromJSON,
  CreateLinkRequestDataToJSON,
  CreateMirrorTopicRequestDataFromJSON,
  CreateMirrorTopicRequestDataToJSON,
  ListLinkConfigsResponseDataFromJSON,
  ListLinkConfigsResponseDataToJSON,
  ListLinkConfigsResponseDataListFromJSON,
  ListLinkConfigsResponseDataListToJSON,
  ListLinksResponseDataFromJSON,
  ListLinksResponseDataToJSON,
  ListLinksResponseDataListFromJSON,
  ListLinksResponseDataListToJSON,
  ListMirrorTopicsResponseDataFromJSON,
  ListMirrorTopicsResponseDataToJSON,
  ListMirrorTopicsResponseDataListFromJSON,
  ListMirrorTopicsResponseDataListToJSON,
  MirrorTopicStatusFromJSON,
  MirrorTopicStatusToJSON,
  UpdateLinkConfigRequestDataFromJSON,
  UpdateLinkConfigRequestDataToJSON,
} from "../models/index";

export interface CreateKafkaLinkRequest {
  cluster_id: string;
  link_name: string;
  validate_only?: boolean;
  validate_link?: boolean;
  CreateLinkRequestData?: CreateLinkRequestData;
}

export interface CreateKafkaMirrorTopicRequest {
  cluster_id: string;
  link_name: string;
  CreateMirrorTopicRequestData?: CreateMirrorTopicRequestData;
}

export interface DeleteKafkaLinkRequest {
  cluster_id: string;
  link_name: string;
  force?: boolean;
  validate_only?: boolean;
}

export interface DeleteKafkaLinkConfigRequest {
  cluster_id: string;
  link_name: string;
  config_name: string;
}

export interface GetKafkaLinkRequest {
  cluster_id: string;
  link_name: string;
  include_tasks?: boolean;
}

export interface GetKafkaLinkConfigsRequest {
  cluster_id: string;
  link_name: string;
  config_name: string;
}

export interface ListKafkaLinkConfigsRequest {
  cluster_id: string;
  link_name: string;
}

export interface ListKafkaLinksRequest {
  cluster_id: string;
}

export interface ListKafkaMirrorTopicsRequest {
  cluster_id: string;
  mirror_status?: MirrorTopicStatus;
}

export interface ListKafkaMirrorTopicsUnderLinkRequest {
  cluster_id: string;
  link_name: string;
  mirror_status?: MirrorTopicStatus;
}

export interface ReadKafkaMirrorTopicRequest {
  cluster_id: string;
  link_name: string;
  mirror_topic_name: string;
  include_state_transition_errors?: boolean;
}

export interface UpdateKafkaLinkConfigRequest {
  cluster_id: string;
  link_name: string;
  config_name: string;
  UpdateLinkConfigRequestData?: UpdateLinkConfigRequestData;
}

export interface UpdateKafkaLinkConfigBatchRequest {
  cluster_id: string;
  link_name: string;
  validate_only?: boolean;
  AlterConfigBatchRequestData?: AlterConfigBatchRequestData;
}

export interface UpdateKafkaMirrorTopicsFailoverRequest {
  cluster_id: string;
  link_name: string;
  validate_only?: boolean;
  AlterMirrorsRequestData?: AlterMirrorsRequestData;
}

export interface UpdateKafkaMirrorTopicsPauseRequest {
  cluster_id: string;
  link_name: string;
  validate_only?: boolean;
  AlterMirrorsRequestData?: AlterMirrorsRequestData;
}

export interface UpdateKafkaMirrorTopicsPromoteRequest {
  cluster_id: string;
  link_name: string;
  validate_only?: boolean;
  AlterMirrorsRequestData?: AlterMirrorsRequestData;
}

export interface UpdateKafkaMirrorTopicsResumeRequest {
  cluster_id: string;
  link_name: string;
  validate_only?: boolean;
  AlterMirrorsRequestData?: AlterMirrorsRequestData;
}

export interface UpdateKafkaMirrorTopicsReverseAndPauseMirrorRequest {
  cluster_id: string;
  link_name: string;
  validate_only?: boolean;
  AlterMirrorsRequestData?: AlterMirrorsRequestData;
}

export interface UpdateKafkaMirrorTopicsReverseAndStartMirrorRequest {
  cluster_id: string;
  link_name: string;
  validate_only?: boolean;
  AlterMirrorsRequestData?: AlterMirrorsRequestData;
}

/**
 *
 */
export class ClusterLinkingV3Api extends runtime.BaseAPI {
  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)  Cluster link creation requires source cluster security configurations in the configs JSON section of the data request payload.
   * Create a cluster link
   */
  async createKafkaLinkRaw(
    requestParameters: CreateKafkaLinkRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling createKafkaLink().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling createKafkaLink().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["link_name"] != null) {
      queryParameters["link_name"] = requestParameters["link_name"];
    }

    if (requestParameters["validate_only"] != null) {
      queryParameters["validate_only"] = requestParameters["validate_only"];
    }

    if (requestParameters["validate_link"] != null) {
      queryParameters["validate_link"] = requestParameters["validate_link"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links`.replace(
          `{${"cluster_id"}}`,
          encodeURIComponent(String(requestParameters["cluster_id"])),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CreateLinkRequestDataToJSON(requestParameters["CreateLinkRequestData"]),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)  Cluster link creation requires source cluster security configurations in the configs JSON section of the data request payload.
   * Create a cluster link
   */
  async createKafkaLink(
    requestParameters: CreateKafkaLinkRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.createKafkaLinkRaw(requestParameters, initOverrides);
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)  Create a topic in the destination cluster mirroring a topic in the source cluster
   * Create a mirror topic
   */
  async createKafkaMirrorTopicRaw(
    requestParameters: CreateKafkaMirrorTopicRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling createKafkaMirrorTopic().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling createKafkaMirrorTopic().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"]))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CreateMirrorTopicRequestDataToJSON(requestParameters["CreateMirrorTopicRequestData"]),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)  Create a topic in the destination cluster mirroring a topic in the source cluster
   * Create a mirror topic
   */
  async createKafkaMirrorTopic(
    requestParameters: CreateKafkaMirrorTopicRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.createKafkaMirrorTopicRaw(requestParameters, initOverrides);
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Delete the cluster link
   */
  async deleteKafkaLinkRaw(
    requestParameters: DeleteKafkaLinkRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling deleteKafkaLink().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling deleteKafkaLink().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["force"] != null) {
      queryParameters["force"] = requestParameters["force"];
    }

    if (requestParameters["validate_only"] != null) {
      queryParameters["validate_only"] = requestParameters["validate_only"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"]))),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Delete the cluster link
   */
  async deleteKafkaLink(
    requestParameters: DeleteKafkaLinkRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.deleteKafkaLinkRaw(requestParameters, initOverrides);
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Reset the given config to default value
   */
  async deleteKafkaLinkConfigRaw(
    requestParameters: DeleteKafkaLinkConfigRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling deleteKafkaLinkConfig().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling deleteKafkaLinkConfig().',
      );
    }

    if (requestParameters["config_name"] == null) {
      throw new runtime.RequiredError(
        "config_name",
        'Required parameter "config_name" was null or undefined when calling deleteKafkaLinkConfig().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}/configs/{config_name}`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"])))
          .replace(
            `{${"config_name"}}`,
            encodeURIComponent(String(requestParameters["config_name"])),
          ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Reset the given config to default value
   */
  async deleteKafkaLinkConfig(
    requestParameters: DeleteKafkaLinkConfigRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.deleteKafkaLinkConfigRaw(requestParameters, initOverrides);
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)  ``link_id`` in ``ListLinksResponseData`` is deprecated and may be removed in a future release. Use the new ``cluster_link_id`` instead.
   * Describe the cluster link
   */
  async getKafkaLinkRaw(
    requestParameters: GetKafkaLinkRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ListLinksResponseData>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling getKafkaLink().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling getKafkaLink().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["include_tasks"] != null) {
      queryParameters["include_tasks"] = requestParameters["include_tasks"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ListLinksResponseDataFromJSON(jsonValue),
    );
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)  ``link_id`` in ``ListLinksResponseData`` is deprecated and may be removed in a future release. Use the new ``cluster_link_id`` instead.
   * Describe the cluster link
   */
  async getKafkaLink(
    requestParameters: GetKafkaLinkRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ListLinksResponseData> {
    const response = await this.getKafkaLinkRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Describe the config under the cluster link
   */
  async getKafkaLinkConfigsRaw(
    requestParameters: GetKafkaLinkConfigsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ListLinkConfigsResponseData>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling getKafkaLinkConfigs().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling getKafkaLinkConfigs().',
      );
    }

    if (requestParameters["config_name"] == null) {
      throw new runtime.RequiredError(
        "config_name",
        'Required parameter "config_name" was null or undefined when calling getKafkaLinkConfigs().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}/configs/{config_name}`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"])))
          .replace(
            `{${"config_name"}}`,
            encodeURIComponent(String(requestParameters["config_name"])),
          ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ListLinkConfigsResponseDataFromJSON(jsonValue),
    );
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Describe the config under the cluster link
   */
  async getKafkaLinkConfigs(
    requestParameters: GetKafkaLinkConfigsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ListLinkConfigsResponseData> {
    const response = await this.getKafkaLinkConfigsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * List all configs of the cluster link
   */
  async listKafkaLinkConfigsRaw(
    requestParameters: ListKafkaLinkConfigsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ListLinkConfigsResponseDataList>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling listKafkaLinkConfigs().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling listKafkaLinkConfigs().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}/configs`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ListLinkConfigsResponseDataListFromJSON(jsonValue),
    );
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * List all configs of the cluster link
   */
  async listKafkaLinkConfigs(
    requestParameters: ListKafkaLinkConfigsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ListLinkConfigsResponseDataList> {
    const response = await this.listKafkaLinkConfigsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)  ``link_id`` in ``ListLinksResponseData`` is deprecated and may be removed in a future release. Use the new ``cluster_link_id`` instead.
   * List all cluster links in the dest cluster
   */
  async listKafkaLinksRaw(
    requestParameters: ListKafkaLinksRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ListLinksResponseDataList>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling listKafkaLinks().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links`.replace(
          `{${"cluster_id"}}`,
          encodeURIComponent(String(requestParameters["cluster_id"])),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ListLinksResponseDataListFromJSON(jsonValue),
    );
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)  ``link_id`` in ``ListLinksResponseData`` is deprecated and may be removed in a future release. Use the new ``cluster_link_id`` instead.
   * List all cluster links in the dest cluster
   */
  async listKafkaLinks(
    requestParameters: ListKafkaLinksRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ListLinksResponseDataList> {
    const response = await this.listKafkaLinksRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)  List all mirror topics in the cluster
   * List mirror topics
   */
  async listKafkaMirrorTopicsRaw(
    requestParameters: ListKafkaMirrorTopicsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ListMirrorTopicsResponseDataList>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling listKafkaMirrorTopics().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["mirror_status"] != null) {
      queryParameters["mirror_status"] = requestParameters["mirror_status"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/-/mirrors`.replace(
          `{${"cluster_id"}}`,
          encodeURIComponent(String(requestParameters["cluster_id"])),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ListMirrorTopicsResponseDataListFromJSON(jsonValue),
    );
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)  List all mirror topics in the cluster
   * List mirror topics
   */
  async listKafkaMirrorTopics(
    requestParameters: ListKafkaMirrorTopicsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ListMirrorTopicsResponseDataList> {
    const response = await this.listKafkaMirrorTopicsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)  List all mirror topics under the link
   * List mirror topics
   */
  async listKafkaMirrorTopicsUnderLinkRaw(
    requestParameters: ListKafkaMirrorTopicsUnderLinkRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ListMirrorTopicsResponseDataList>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling listKafkaMirrorTopicsUnderLink().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling listKafkaMirrorTopicsUnderLink().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["mirror_status"] != null) {
      queryParameters["mirror_status"] = requestParameters["mirror_status"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ListMirrorTopicsResponseDataListFromJSON(jsonValue),
    );
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)  List all mirror topics under the link
   * List mirror topics
   */
  async listKafkaMirrorTopicsUnderLink(
    requestParameters: ListKafkaMirrorTopicsUnderLinkRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ListMirrorTopicsResponseDataList> {
    const response = await this.listKafkaMirrorTopicsUnderLinkRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Describe the mirror topic
   */
  async readKafkaMirrorTopicRaw(
    requestParameters: ReadKafkaMirrorTopicRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ListMirrorTopicsResponseData>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling readKafkaMirrorTopic().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling readKafkaMirrorTopic().',
      );
    }

    if (requestParameters["mirror_topic_name"] == null) {
      throw new runtime.RequiredError(
        "mirror_topic_name",
        'Required parameter "mirror_topic_name" was null or undefined when calling readKafkaMirrorTopic().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["include_state_transition_errors"] != null) {
      queryParameters["include_state_transition_errors"] =
        requestParameters["include_state_transition_errors"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors/{mirror_topic_name}`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"])))
          .replace(
            `{${"mirror_topic_name"}}`,
            encodeURIComponent(String(requestParameters["mirror_topic_name"])),
          ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ListMirrorTopicsResponseDataFromJSON(jsonValue),
    );
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Describe the mirror topic
   */
  async readKafkaMirrorTopic(
    requestParameters: ReadKafkaMirrorTopicRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ListMirrorTopicsResponseData> {
    const response = await this.readKafkaMirrorTopicRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Alter the config under the cluster link
   */
  async updateKafkaLinkConfigRaw(
    requestParameters: UpdateKafkaLinkConfigRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling updateKafkaLinkConfig().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling updateKafkaLinkConfig().',
      );
    }

    if (requestParameters["config_name"] == null) {
      throw new runtime.RequiredError(
        "config_name",
        'Required parameter "config_name" was null or undefined when calling updateKafkaLinkConfig().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}/configs/{config_name}`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"])))
          .replace(
            `{${"config_name"}}`,
            encodeURIComponent(String(requestParameters["config_name"])),
          ),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: UpdateLinkConfigRequestDataToJSON(requestParameters["UpdateLinkConfigRequestData"]),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Alter the config under the cluster link
   */
  async updateKafkaLinkConfig(
    requestParameters: UpdateKafkaLinkConfigRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.updateKafkaLinkConfigRaw(requestParameters, initOverrides);
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)  Batch Alter Cluster Link Configs
   * Batch Alter Cluster Link Configs
   */
  async updateKafkaLinkConfigBatchRaw(
    requestParameters: UpdateKafkaLinkConfigBatchRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling updateKafkaLinkConfigBatch().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling updateKafkaLinkConfigBatch().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["validate_only"] != null) {
      queryParameters["validate_only"] = requestParameters["validate_only"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}/configs:alter`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"]))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: AlterConfigBatchRequestDataToJSON(requestParameters["AlterConfigBatchRequestData"]),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)  Batch Alter Cluster Link Configs
   * Batch Alter Cluster Link Configs
   */
  async updateKafkaLinkConfigBatch(
    requestParameters: UpdateKafkaLinkConfigBatchRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.updateKafkaLinkConfigBatchRaw(requestParameters, initOverrides);
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Failover the mirror topics
   */
  async updateKafkaMirrorTopicsFailoverRaw(
    requestParameters: UpdateKafkaMirrorTopicsFailoverRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AlterMirrorStatusResponseDataList>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling updateKafkaMirrorTopicsFailover().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling updateKafkaMirrorTopicsFailover().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["validate_only"] != null) {
      queryParameters["validate_only"] = requestParameters["validate_only"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:failover`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"]))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: AlterMirrorsRequestDataToJSON(requestParameters["AlterMirrorsRequestData"]),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AlterMirrorStatusResponseDataListFromJSON(jsonValue),
    );
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Failover the mirror topics
   */
  async updateKafkaMirrorTopicsFailover(
    requestParameters: UpdateKafkaMirrorTopicsFailoverRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AlterMirrorStatusResponseDataList> {
    const response = await this.updateKafkaMirrorTopicsFailoverRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Pause the mirror topics
   */
  async updateKafkaMirrorTopicsPauseRaw(
    requestParameters: UpdateKafkaMirrorTopicsPauseRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AlterMirrorStatusResponseDataList>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling updateKafkaMirrorTopicsPause().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling updateKafkaMirrorTopicsPause().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["validate_only"] != null) {
      queryParameters["validate_only"] = requestParameters["validate_only"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:pause`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"]))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: AlterMirrorsRequestDataToJSON(requestParameters["AlterMirrorsRequestData"]),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AlterMirrorStatusResponseDataListFromJSON(jsonValue),
    );
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Pause the mirror topics
   */
  async updateKafkaMirrorTopicsPause(
    requestParameters: UpdateKafkaMirrorTopicsPauseRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AlterMirrorStatusResponseDataList> {
    const response = await this.updateKafkaMirrorTopicsPauseRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Promote the mirror topics
   */
  async updateKafkaMirrorTopicsPromoteRaw(
    requestParameters: UpdateKafkaMirrorTopicsPromoteRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AlterMirrorStatusResponseDataList>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling updateKafkaMirrorTopicsPromote().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling updateKafkaMirrorTopicsPromote().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["validate_only"] != null) {
      queryParameters["validate_only"] = requestParameters["validate_only"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:promote`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"]))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: AlterMirrorsRequestDataToJSON(requestParameters["AlterMirrorsRequestData"]),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AlterMirrorStatusResponseDataListFromJSON(jsonValue),
    );
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Promote the mirror topics
   */
  async updateKafkaMirrorTopicsPromote(
    requestParameters: UpdateKafkaMirrorTopicsPromoteRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AlterMirrorStatusResponseDataList> {
    const response = await this.updateKafkaMirrorTopicsPromoteRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Resume the mirror topics
   */
  async updateKafkaMirrorTopicsResumeRaw(
    requestParameters: UpdateKafkaMirrorTopicsResumeRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AlterMirrorStatusResponseDataList>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling updateKafkaMirrorTopicsResume().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling updateKafkaMirrorTopicsResume().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["validate_only"] != null) {
      queryParameters["validate_only"] = requestParameters["validate_only"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:resume`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"]))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: AlterMirrorsRequestDataToJSON(requestParameters["AlterMirrorsRequestData"]),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AlterMirrorStatusResponseDataListFromJSON(jsonValue),
    );
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Resume the mirror topics
   */
  async updateKafkaMirrorTopicsResume(
    requestParameters: UpdateKafkaMirrorTopicsResumeRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AlterMirrorStatusResponseDataList> {
    const response = await this.updateKafkaMirrorTopicsResumeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Reverse the local mirror topic and Pause the remote mirror topic
   */
  async updateKafkaMirrorTopicsReverseAndPauseMirrorRaw(
    requestParameters: UpdateKafkaMirrorTopicsReverseAndPauseMirrorRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AlterMirrorStatusResponseDataList>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling updateKafkaMirrorTopicsReverseAndPauseMirror().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling updateKafkaMirrorTopicsReverseAndPauseMirror().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["validate_only"] != null) {
      queryParameters["validate_only"] = requestParameters["validate_only"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:reverse-and-pause-mirror`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"]))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: AlterMirrorsRequestDataToJSON(requestParameters["AlterMirrorsRequestData"]),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AlterMirrorStatusResponseDataListFromJSON(jsonValue),
    );
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Reverse the local mirror topic and Pause the remote mirror topic
   */
  async updateKafkaMirrorTopicsReverseAndPauseMirror(
    requestParameters: UpdateKafkaMirrorTopicsReverseAndPauseMirrorRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AlterMirrorStatusResponseDataList> {
    const response = await this.updateKafkaMirrorTopicsReverseAndPauseMirrorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Reverse the local mirror topic and start the remote mirror topic
   */
  async updateKafkaMirrorTopicsReverseAndStartMirrorRaw(
    requestParameters: UpdateKafkaMirrorTopicsReverseAndStartMirrorRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AlterMirrorStatusResponseDataList>> {
    if (requestParameters["cluster_id"] == null) {
      throw new runtime.RequiredError(
        "cluster_id",
        'Required parameter "cluster_id" was null or undefined when calling updateKafkaMirrorTopicsReverseAndStartMirror().',
      );
    }

    if (requestParameters["link_name"] == null) {
      throw new runtime.RequiredError(
        "link_name",
        'Required parameter "link_name" was null or undefined when calling updateKafkaMirrorTopicsReverseAndStartMirror().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["validate_only"] != null) {
      queryParameters["validate_only"] = requestParameters["validate_only"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "external-access-token",
        [],
      );
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined || this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:reverse-and-start-mirror`
          .replace(`{${"cluster_id"}}`, encodeURIComponent(String(requestParameters["cluster_id"])))
          .replace(`{${"link_name"}}`, encodeURIComponent(String(requestParameters["link_name"]))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: AlterMirrorsRequestDataToJSON(requestParameters["AlterMirrorsRequestData"]),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AlterMirrorStatusResponseDataListFromJSON(jsonValue),
    );
  }

  /**
   * [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
   * Reverse the local mirror topic and start the remote mirror topic
   */
  async updateKafkaMirrorTopicsReverseAndStartMirror(
    requestParameters: UpdateKafkaMirrorTopicsReverseAndStartMirrorRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AlterMirrorStatusResponseDataList> {
    const response = await this.updateKafkaMirrorTopicsReverseAndStartMirrorRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }
}
